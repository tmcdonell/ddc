<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Concrete Syntax &#8212; Disciple 0.5.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/haiku-mod.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.5.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Core Language" href="../02-Core.html" />
    <link rel="prev" title="Source Language" href="../01-Source.html" /> 
  </head>
  <body role="document">
      <div class="header" role="banner"><h1 class="heading"><a href="../../index.html">
          <span>Disciple 0.5.1 documentation</span></a></h1>
        <h2 class="heading"><span>Concrete Syntax</span></h2>
      </div>
      <div class="topnav" role="navigation" aria-label="top navigation">
      
        <p>
        «&#160;&#160;<a href="../01-Source.html">Source Language</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../02-Core.html">Core Language</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="concrete-syntax">
<h1>Concrete Syntax<a class="headerlink" href="#concrete-syntax" title="Permalink to this headline">¶</a></h1>
<div class="section" id="modules">
<h2>Modules<a class="headerlink" href="#modules" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none"><div class="highlight"><pre><span></span>Module                                              (source modules)
 ::= &#39;module&#39; ModuleName
        ExportSpecs* ImportSpecs*;
       &#39;where&#39;  &#39;{&#39; Decl*; &#39;}&#39;

ExportSpecs                                         (export specifications)
 ::= &#39;export&#39; &#39;{&#39; Var+; &#39;}&#39;

ImportSpecs                                         (import specifications)
 ::= &#39;import&#39; &#39;{&#39; ModuleName;+ &#39;}&#39;                  (module imports)
  |  &#39;import&#39; &#39;foreign&#39; ImportSpecsForeign          (foreign imports)

ImportSpecsForeign                                  (foreign import specification)
 ::= &#39;boxed&#39;    &#39;type&#39;       &#39;{&#39; ConSig;+ &#39;}&#39;       (foreign boxed type import)
  |  &#39;abstract&#39; &#39;type&#39;       &#39;{&#39; ConSig;+ &#39;}&#39;       (foreign abstract type import)
  |  &#39;abstract&#39; &#39;capability&#39; &#39;{&#39; VarSig;+ &#39;}&#39;       (foreign abstract capability import)
  |  &#39;c&#39;        &#39;value&#39;      &#39;{&#39; VarSig;+ &#39;}&#39;       (foreign c value import)

VarSig  ::= &#39;Var&#39; &#39;:&#39; Type                          (variable type signature)
ConSig  ::= &#39;Con&#39; &#39;:&#39; Type                          (constructor type signature)
</pre></div>
</div>
<p>Source modules begin with the keyword <code class="docutils literal"><span class="pre">module</span></code> followed by a module name, then some
optional export and import specifications, then some declarations. The export specifications must come before
the import specifications.</p>
<p>Export specifications list names of term bindings to export.</p>
<p>Import specifications list modules or foreign things to import.</p>
<p>Foreign types, capabilities and values can be imported. Foreign boxed types classify values that are stored in the Disciple runtime heap and have the standard format expected by the runtime system. Foreign abstract types are used to classify values that are not stored in the Disciple runtime heap. Foreign abstract capabilities such as &#8216;Console&#8217; and &#8216;File&#8217; are used for effects that alter the foreign world. Foreign c values are functions accessible via the standard C calling convention.</p>
<p>Braces in the <code class="docutils literal"><span class="pre">Module</span></code>, <code class="docutils literal"><span class="pre">ExportSpecs</span></code>, <code class="docutils literal"><span class="pre">ImportSpecs</span></code> and <code class="docutils literal"><span class="pre">ImportSpecsForeign</span></code> productions will be inserted using the off-side rule.</p>
<p>See the <a class="reference external" href="https://github.com/DDCSF/ddc/tree/ddc-0.5.1/test/ddc-spec/source/01-Tetra/01-Syntax/01-Module">module specification tests</a> for examples.</p>
</div>
<div class="section" id="declarations">
<h2>Declarations<a class="headerlink" href="#declarations" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none"><div class="highlight"><pre><span></span>Decl                                                (declaration)
 ::= DeclType | DeclData | DeclValue

DeclType                                            (type declaration)
 ::= &#39;type&#39; Con &#39;=&#39; Type                            (type synonym declaration)

DeclData                                            (data type declaration)
 ::= &#39;data&#39; Con DeclDataParams*
        (&#39;where&#39; &#39;{&#39; (Con &#39;:&#39; Type)+; &#39;}&#39;)?

DeclDataParams                                      (data type parameters)
 ::= &#39;(&#39; Var+ &#39;:&#39; Type &#39;)&#39;                          (data type parameters with shared kind)

DeclTerm                                            (term declaration)
 ::= Var &#39;:&#39; Type                                   (type signature)

  |  Var DeclTermParams* (&#39;:&#39; Type)?
         GuardedExpsMaybe                           (term declaration using guards)

DeclTermParams                                      (term declaration parameters)
 ::= PatBase                                        (simple pattern)
  |  &#39;(&#39; PatBase+ &#39;:&#39; Type &#39;}&#39;                      (patterns with shared type annotation)
  |  &#39;{&#39; PatBase+ &#39;:&#39; Type &#39;}&#39;                      (implicit term parameters)
  |  &#39;{&#39; Type &#39;}&#39;                                   (anonymous implicit term parameter)
  |  &#39;{&#39; &#39;@&#39; Var+   &#39;:&#39; Type &#39;}&#39;                    (implicit type parameters)
</pre></div>
</div>
<p>Type declarations define unparameterised type synonyms. (<a class="reference external" href="http://trac.ouroborus.net/ddc/ticket/385">Issue385</a>) covers addition of type parameters.</p>
<p>Data type declarations define parameterised data types, giving the types of their data constructors. The return type of each constructor must match the data type being defined. It is valid to define a data type with no data constructors.</p>
<p>Term declarations are either type signatures or declarations that can mention function parameters, have an optional result type, and are defined in terms of guarded expressions.</p>
<p>Type parameters give the name of each parameter with an optional kind annotation. Multiple parameters can be defined that share a common kind annotation.</p>
<p>Term declaration parameters can be either type parameters with a shared kind, an anonymous or named implicit parameter, or a term parameter defined via pattern matching.</p>
<p>Braces in the <code class="docutils literal"><span class="pre">DeclData</span></code> production will be inserted using the off-side rule.</p>
<p>See the <a class="reference external" href="https://github.com/DDCSF/ddc/tree/ddc-0.5.1/test/ddc-spec/source/01-Tetra/01-Syntax/02-Decl/Main.ds">declaration specification tests</a> for examples.</p>
</div>
<div class="section" id="types">
<h2>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none"><div class="highlight"><pre><span></span>Type
 ::= TypeFun + Type                                 (type sum)
  |  TypeFun                                        (functional type)

TypeFun
 ::= TypeApp                                        (type application)
  |  TypeApp &#39;-&gt;&#39; TypeFun                           (explicit function type)
  |  TypeApp &#39;~&gt;&#39; TypeFun                           (implicit function type)
  |  &#39;{&#39; Type &#39;}&#39; &#39;-&gt;&#39; TypeFun                      (implicit function type, alternate syntax)
  |  &#39;(&#39; &#39;@&#39; Var+ &#39;:&#39; Type &#39;)&#39; &#39;~&gt;&#39; TypeFun         (implicit universal quantification)
  |  &#39;{&#39; &#39;@&#39; Var+ &#39;:&#39; Type &#39;}&#39; &#39;-&gt;&#39; TypeFun         (implicit universal quantification, alternate syntax)

TypeApp                                             (type application)
 ::= TypeApp TypeArg                                (type function applied to an argument)
  |  TypeArg                                        (type argument)

TypeArg
 ::= Var                                            (type variable)
  |  Con                                            (type constructor)
  |  &#39;(&#39; Type &#39;,&#39; Type+, &#39;)&#39;                        (tuple type)
  |  &#39;(&#39; Type &#39;)&#39;                                   (parenthesised type)

TypeBuiltin
 ::= &#39;Data&#39; | &#39;Region&#39; | &#39;Effect&#39;                   (builtin kind constructors)
  |  &#39;Pure&#39; | &#39;Read&#39;   | &#39;Write&#39; | &#39;Alloc&#39;          (builtin effect type constructors)
  |  &#39;Unit&#39;                                         (builtin data type constructors)
  |  &#39;(-&gt;)&#39;                                         (explicit function type constructor)
  |  &#39;(~&gt;)&#39;                                         (implicit function type constructor)
</pre></div>
</div>
<p>Type sums are used to collect together multiple effect types.</p>
<p>Function types include both a parameter and return type, using <code class="docutils literal"><span class="pre">-&gt;</span></code> as the constructor for explicit function types and <code class="docutils literal"><span class="pre">~&gt;</span></code> as the constructor for implicit function types. Alternately, implicit function types can be written <code class="docutils literal"><span class="pre">{t1}</span> <span class="pre">-&gt;</span> <span class="pre">t2</span></code> where <code class="docutils literal"><span class="pre">t1</span></code> is the parameter type and <code class="docutils literal"><span class="pre">t2</span></code> is the result type.</p>
<p>Similarly, implicit universal quantification over some type variable <code class="docutils literal"><span class="pre">v</span></code> of kind <code class="docutils literal"><span class="pre">k</span></code> is written <code class="docutils literal"><span class="pre">(&#64;v:t1)</span> <span class="pre">~&gt;</span> <span class="pre">t2</span></code>, where <code class="docutils literal"><span class="pre">k1</span></code> is the kind of the parameter variable and <code class="docutils literal"><span class="pre">t2</span></code> is the body type. Alternatively, implicit universal quantification can be written <code class="docutils literal"><span class="pre">{&#64;v:t1}</span> <span class="pre">-&gt;</span> <span class="pre">t2</span></code> using braces to indicate that the type argument will be passed implicitly. The <code class="docutils literal"><span class="pre">&#64;</span></code> in this syntax indicates that variable <code class="docutils literal"><span class="pre">v</span></code> is a type binder rather than a term binder.</p>
<p>Type applications are between a type function and its argument.</p>
<p>Type arguments include variables, constructors, tuple types and parenthesised types. A tuple type like <code class="docutils literal"><span class="pre">(t1,</span> <span class="pre">t2,</span> <span class="pre">..</span> <span class="pre">tN)</span></code> is sugar for the type application <code class="docutils literal"><span class="pre">TupN</span> <span class="pre">t1</span> <span class="pre">t2</span> <span class="pre">..</span> <span class="pre">tN</span></code>, where the type constructor <code class="docutils literal"><span class="pre">TupN</span></code> is taken as whatever type constructor is currently in scope with that name.</p>
<p>Builtin type constructors consist of kind constructors, effect type constructors, data type constructors and function type constructors. The same grammar is used for both types and kinds. <code class="docutils literal"><span class="pre">Data</span></code> is the kind of data types, <code class="docutils literal"><span class="pre">Region</span></code> the kind of effect types and <code class="docutils literal"><span class="pre">Effect</span></code> the kind of effect types. <code class="docutils literal"><span class="pre">Pure</span></code> is the effect of pure expressions and the zero element of type sums. <code class="docutils literal"><span class="pre">Read</span></code>, <code class="docutils literal"><span class="pre">Write</span></code> and <code class="docutils literal"><span class="pre">Alloc</span></code> are effect type constructors for their associated effects. <code class="docutils literal"><span class="pre">Unit</span></code> is the type of the primitive unit value <code class="docutils literal"><span class="pre">()</span></code>. <code class="docutils literal"><span class="pre">(-&gt;)</span></code> is the explicit function type constructor and <code class="docutils literal"><span class="pre">(~&gt;)</span></code> the implicit function type constructor.</p>
<p>See the <a class="reference external" href="https://github.com/DDCSF/ddc/tree/ddc-0.5.1/test/ddc-spec/source/01-Tetra/01-Syntax/03-Types/Main.ds">type specification tests</a> for examples.</p>
</div>
<div class="section" id="guarded-expressions">
<h2>Guarded Expressions<a class="headerlink" href="#guarded-expressions" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none"><div class="highlight"><pre><span></span>GuardedExpsMaybe                                    (maybe guarded expressions)
 ::= &#39;=&#39; Exp                                        (simple unguarded expression)
  |  GuardedExp*                                    (multiple guarded expressions)

GuardedExp
 ::= &#39;|&#39; Guard,+ &#39;=&#39; Exp                            (guarded expression)

Guard
 ::= &#39;otherwise&#39;                                    (otherwise guard always matches)
  |  Pat &#39;&lt;-&#39; Exp                                   (match against pattern)
  |  Exp                                            (boolean predicate)
</pre></div>
</div>
<p>The bodies of term declarations can be defined either with a single expression or using multiple guarded expressions.</p>
<p>The <code class="docutils literal"><span class="pre">otherwise</span></code> guard always succeeds. The <code class="docutils literal"><span class="pre">Pat</span> <span class="pre">'&lt;-'</span> <span class="pre">Exp</span></code> guard succeeds when the value produced by <code class="docutils literal"><span class="pre">Exp</span></code> can be matched against <code class="docutils literal"><span class="pre">Pat</span></code>. The boolean predicate guard suceeds when the resulting value is <code class="docutils literal"><span class="pre">True</span></code>.</p>
<p>See the <a class="reference external" href="https://github.com/DDCSF/ddc/tree/ddc-0.5.1/test/ddc-spec/source/01-Tetra/01-Syntax/04-Guards/Main.ds">guards specification tests</a> for examples.</p>
</div>
<div class="section" id="terms">
<h2>Terms<a class="headerlink" href="#terms" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none"><div class="highlight"><pre><span></span>Exp
 ::= ExpApp (&#39;where&#39; &#39;{&#39; DeclTerm;+ &#39;}&#39;)?           (expression with optional where clause)

ExpApp                                              (applicative expressions)
 ::= ExpAppPrefix |  ExpAppInfix
  |  ExpAppAbs    |  ExpAppBind
  |  ExpAppMatch  |  ExpAppEffect

ExpAppPrefix                                        (prefix application)
 ::= ExpBase ExpArg*                                (base expression applied to arguments)

ExpAppInfix                                         (infix application)
 ::= ExpApp InfixOp ExpApp                          (application of infix operator)
  |  ExpBase

ExpArg                                              (function argument)
 ::= &#39;{&#39;  Exp  &#39;}&#39;                                  (implicit term argument)
  |  &#39;{&#39; &#39;@&#39; Type &#39;}&#39;                               (implicit type argument)
  |  ExpBase                                        (base expression)

ExpBase
 ::= &#39;()&#39;                                           (unit  data constructor)
  |  DaCon                                          (named data constructor)
  |  Literal                                        (literal value)
  |  Var                                            (named variable)
  |  &#39;(&#39; InfixOp &#39;)&#39;                                (reference to infix operator)
  |  &#39;(&#39; Exp &#39;,&#39; Exp+, &#39;)&#39;                          (tuple expression)
  |  &#39;(&#39; Exp &#39;)&#39;                                    (parenthesised expression)
</pre></div>
</div>
<p>Terms include prefix application, infix application, abstractions, binding forms, matching and effectful terms. The later forms are described in the following sections.</p>
<p>Expressions can include nested &#8216;where&#8217; bindings, where the local declarations can include type signatures.</p>
<p>Prefix and infix application is standard.</p>
<p>Explicit arguments for implicit term parameters are supplied using <code class="docutils literal"><span class="pre">{}</span></code> parenthesis, and explicit arguments for implicit type parameters with <code class="docutils literal"><span class="pre">{&#64;</span> <span class="pre">}</span></code> parenthesis.</p>
<p>See the <a class="reference external" href="https://github.com/DDCSF/ddc/tree/ddc-0.5.1/test/ddc-spec/source/01-Tetra/01-Syntax/05-Term/Main.ds">term specification tests</a> for examples.</p>
</div>
<div class="section" id="abstraction">
<h2>Abstraction<a class="headerlink" href="#abstraction" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none"><div class="highlight"><pre><span></span>ExpAppAbs
 ::= &#39;\&#39; ExpParam &#39;-&gt;&#39; Exp                          (abstraction)

ExpAbsParam
 ::=  PatBase+                                      (explicit unannotated term parameter}
  |  &#39;(&#39; PatBase+ &#39;:&#39; Type &#39;)&#39;                      (explicit annotated term parameter)
  |  &#39;{&#39; PatBase+ &#39;:&#39; Type &#39;}&#39;                      (implicit annotated term parameter)
  |  &#39;{&#39; &#39;@&#39; Var+   &#39;:&#39; Type &#39;}&#39;                    (implicit annotated type parmaeter)
</pre></div>
</div>
<p>Abstractions begin with a <code class="docutils literal"><span class="pre">\</span></code>, followed by some parameter bindings, then a <code class="docutils literal"><span class="pre">-&gt;</span></code>. In the concrete syntax the unicode characters <code class="docutils literal"><span class="pre">λ</span></code> and <code class="docutils literal"><span class="pre">→</span></code> can be used in place of <code class="docutils literal"><span class="pre">\</span></code> and <code class="docutils literal"><span class="pre">-&gt;</span></code>. Term parameter can be bound by patterns with or without type annotations. Explicit term parameters are specified with <code class="docutils literal"><span class="pre">()</span></code> parenthesis and implicit term parameters with <code class="docutils literal"><span class="pre">{}</span></code> parenthesis. Implicit type parameters are specified with <code class="docutils literal"><span class="pre">{&#64;</span> <span class="pre">}</span></code> parenthesis, where the <code class="docutils literal"><span class="pre">{}</span></code> refers to the fact the type arguments will be passed implicitly at the call site, and the <code class="docutils literal"><span class="pre">&#64;</span></code> refers to the name space of type variables.</p>
<p>See the <a class="reference external" href="https://github.com/DDCSF/ddc/tree/ddc-0.5.1/test/ddc-spec/source/01-Tetra/01-Syntax/06-Abs/Main.ds">abstraction specification tests</a> for examples.</p>
</div>
<div class="section" id="binding">
<h2>Binding<a class="headerlink" href="#binding" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none"><div class="highlight"><pre><span></span>ExpAppBind
 ::= &#39;let&#39;    DeclTerm   &#39;in&#39; Exp                   (non-recursive let binding)
  |  &#39;letrec&#39; DeclTerm+; &#39;in&#39; Exp                   (recursive let bindings)
  |  &#39;do&#39;    &#39;{&#39; Stmt+; &#39;}&#39;                         (do expression)
</pre></div>
</div>
</div>
<div class="section" id="matching">
<h2>Matching<a class="headerlink" href="#matching" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none"><div class="highlight"><pre><span></span>ExpAppMatch
 ::= &#39;case&#39;  &#39;{&#39; AltCase+; &#39;}&#39;                      (case expression)
  |  &#39;match&#39; &#39;{&#39; GuardedExp+; &#39;}&#39;                   (match expression)
  |  &#39;if&#39; Exp &#39;then&#39; Exp &#39;else&#39; Exp                 (if-expression)

AltCase
 ::= Pat GuardedExp* &#39;-&gt;&#39; Exp                       (case alternative)

Pat
 ::= DaCon PatBase*                                 (data constructor patterm)
  |  PatBase                                        (base pattern)

PatBase
 ::= &#39;()&#39;                                           (unit data constructor pattern)
  |  DaCon                                          (named data constructor pattern)
  |  Literal                                        (literal pattern)
  |  Var                                            (variable pattern)
  |  &#39;_&#39;                                            (wildcard pattern)
  |  &#39;(&#39; Pat &#39;,&#39; Pat+ &#39;)&#39;                           (tuple pattern)
  |  &#39;(&#39; Pat &#39;)&#39;                                    (parenthesised pattern)
</pre></div>
</div>
</div>
<div class="section" id="regions-and-effects">
<h2>Regions and Effects<a class="headerlink" href="#regions-and-effects" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none"><div class="highlight"><pre><span></span>ExpAppEffect
 ::= &#39;weakeff&#39; &#39;[&#39; Type &#39;]&#39; &#39;in&#39; Exp                (weaken effect of an expression)

  |  &#39;private&#39; Bind+ WithCaps? &#39;in&#39; Exp             (private region introduction)

  |  &#39;extend&#39;  Bind &#39;using&#39; Bind+
               WithCaps? &#39;in&#39; Exp                   (region extension)

  |  &#39;box&#39; Exp                                      (box a computation)
  |  &#39;run&#39; Exp                                      (run a boxed computation)

WithCaps
 ::= &#39;with&#39; &#39;{&#39; BindT+ &#39;}&#39;
</pre></div>
</div>
</div>
</div>


      </div>
      <div class="bottomnav" role="navigation" aria-label="bottom navigation">
      
        <p>
        «&#160;&#160;<a href="../01-Source.html">Source Language</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="../02-Core.html">Core Language</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Disciple Development Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6.
    </div>
  </body>
</html>