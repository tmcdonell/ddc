ok
ok
ok


-- Check that the size prims are available
size# :: [^: Data].Nat#
size2# :: [^: Data].Nat#


-- Get the size of prim types.
%s.Obj = type <{i64}>
@ddcHeapMax = external global  i64
@ddcHeapTop = external global  i64
declare external ccc void @abort() align 8
declare external void @llvm.gcroot(i8** , i8* )
declare external void @llvm.memcpy.p0i8.p0i8.i64(i8* , i8* , i64 , i32 , i1 )
declare external void @llvm.memset.p0i8.i64(i8* , i8 , i64 , i32 , i1 )

define internal fastcc i64 @nat(%s.Obj*  %_v1.x0) align 8 gc "shadow-stack"  
{
l2.init:
        br label %l3.body
l3.body:
        ret i64 8
}

define internal fastcc i64 @int(%s.Obj*  %_v5.x1) align 8 gc "shadow-stack"  
{
l6.init:
        br label %l7.body
l7.body:
        ret i64 8
}

define internal fastcc i64 @word16(%s.Obj*  %_v9.x2) align 8 gc "shadow-stack"  
{
l10.init:
        br label %l11.body
l11.body:
        ret i64 2
}

define internal fastcc i64 @tag(%s.Obj*  %_v13.x3) align 8 gc "shadow-stack"  
{
l14.init:
        br label %l15.body
l15.body:
        ret i64 4
}







-- Get the log2 size of prim types.
%s.Obj = type <{i64}>
@ddcHeapMax = external global  i64
@ddcHeapTop = external global  i64
declare external ccc void @abort() align 8
declare external void @llvm.gcroot(i8** , i8* )
declare external void @llvm.memcpy.p0i8.p0i8.i64(i8* , i8* , i64 , i32 , i1 )
declare external void @llvm.memset.p0i8.i64(i8* , i8 , i64 , i32 , i1 )

define internal fastcc i64 @nat(%s.Obj*  %_v1.x0) align 8 gc "shadow-stack"  
{
l2.init:
        br label %l3.body
l3.body:
        ret i64 3
}

define internal fastcc i64 @int(%s.Obj*  %_v5.x1) align 8 gc "shadow-stack"  
{
l6.init:
        br label %l7.body
l7.body:
        ret i64 3
}

define internal fastcc i64 @word8(%s.Obj*  %_v9.x2) align 8 gc "shadow-stack"  
{
l10.init:
        br label %l11.body
l11.body:
        ret i64 0
}

define internal fastcc i64 @word16(%s.Obj*  %_v13.x3) align 8 gc "shadow-stack"  
{
l14.init:
        br label %l15.body
l15.body:
        ret i64 1
}

define internal fastcc i64 @ptr(%s.Obj*  %_v17.x4) align 8 gc "shadow-stack"  
{
l21.init:
        br label %l22.body
l22.body:
        ret i64 3
}

define internal fastcc i64 @tag(%s.Obj*  %_v24.x5) align 8 gc "shadow-stack"  
{
l25.init:
        br label %l26.body
l26.body:
        ret i64 2
}



!20 = !{!"ptr_r",  !19, i64 0}
!19 = !{!"ptr_ROOT_18"}



-- Function arguments without names still need to appear in the generated code.
%s.Obj = type <{i64}>
@ddcHeapMax = external global  i64
@ddcHeapTop = external global  i64
declare external ccc void @abort() align 8
declare external void @llvm.gcroot(i8** , i8* )
declare external void @llvm.memcpy.p0i8.p0i8.i64(i8* , i8* , i64 , i32 , i1 )
declare external void @llvm.memset.p0i8.i64(i8* , i8 , i64 , i32 , i1 )

define internal fastcc i64 @blerk(%s.Obj*  %_v1.x0) align 8 gc "shadow-stack"  
{
l2.init:
        br label %l3.body
l3.body:
        ret i64 3
}





